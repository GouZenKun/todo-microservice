package main

import (
	"context"
	"crypto/tls"
	"errors"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"os"
	"time"

	"connectrpc.com/connect"
	"github.com/urfave/cli/v2"
	"golang.org/x/net/http2"

	todov1 "todo_module/internal/controller/gen/proto/v1"        // generated by protoc-gen-go
	"todo_module/internal/controller/gen/proto/v1/todov1connect" // generated by protoc-gen-connect-go
	"todo_module/util"
)

func main() {
	// VAR
	cmd_flags := []cli.Flag{
		&cli.StringFlag{
			Name:    "hostname",
			Aliases: []string{"H"},
			Value:   "localhost",
			Usage:   "hostname for the server",
		},
		&cli.StringFlag{
			Name:    "port",
			Aliases: []string{"p"},
			Value:   "3000",
			Usage:   "port for the server",
		},
		&cli.BoolFlag{
			Name:    "secure",
			Aliases: []string{"s"},
			Value:   false,
			Usage:   "use HTTPS",
		},
	}

	// CLI APP
	app := &cli.App{
		EnableBashCompletion: true,
		Commands: []*cli.Command{
			{
				Name:    "add",
				Aliases: []string{"a"},
				Usage:   "Add a todo",
				Action: func(cCtx *cli.Context) error {
					add(cCtx)
					return nil
				},
				Flags: append([]cli.Flag{
					&cli.StringFlag{
						Name:     "title",
						Usage:    "Title of the todo",
						Required: true,
					},
					&cli.StringFlag{
						Name:     "desc",
						Usage:    "Description of the todo",
						Required: true,
					},
					&cli.StringFlag{
						Name:     "status",
						Usage:    "Status of the todo [Completed, Pending, Incomplete]",
						Required: true,
					},
					&cli.TimestampFlag{
						Name:     "due-date",
						Usage:    "Due date of the todo",
						Layout:   time.DateOnly,
						Required: true,
					},
				},
					cmd_flags...,
				),
			},
			{
				Name:  "add-dummy",
				Usage: "add dummy data",
				Action: func(cCtx *cli.Context) error {
					addDummy(cCtx)
					return nil
				},
				Flags: cmd_flags,
			},
			{
				Name:      "get",
				Aliases:   []string{"g"},
				Usage:     "get a todo",
				ArgsUsage: "[id]",
				Action: func(cCtx *cli.Context) error {
					get(cCtx)
					return nil
				},
				Flags: cmd_flags,
			},
			{
				Name:    "edit",
				Aliases: []string{"u"},
				Usage:   "edit a todo",
				Action: func(cCtx *cli.Context) error {
					edit(cCtx)
					return nil
				},
				Flags: append([]cli.Flag{
					&cli.StringFlag{
						Name:     "id",
						Usage:    "ID of the todo",
						Required: true,
					},
					&cli.StringFlag{
						Name:     "title",
						Usage:    "Title of the todo",
						Required: true,
					},
					&cli.StringFlag{
						Name:     "desc",
						Usage:    "Description of the todo",
						Required: true,
					},
					&cli.StringFlag{
						Name:     "status",
						Usage:    "Status of the todo",
						Required: true,
					},
					&cli.TimestampFlag{
						Name:     "due-date",
						Usage:    "Due date of the todo",
						Layout:   time.DateOnly,
						Required: true,
					}},
					cmd_flags...,
				),
			},
			{
				Name:      "remove",
				Aliases:   []string{"r"},
				Usage:     "remove a todo",
				ArgsUsage: "[id]",
				Action: func(cCtx *cli.Context) error {
					remove(cCtx)
					return nil
				},
				Flags: cmd_flags,
			},
			{
				Name:    "list",
				Aliases: []string{"l"},
				Usage:   "list all todos",
				Action: func(cCtx *cli.Context) error {
					list(cCtx)
					return nil
				},
				Flags: append([]cli.Flag{
					&cli.StringFlag{
						Name:    "filter-by-status",
						Aliases: []string{"f"},
						Value:   "",
						Usage:   "filter data by status",
					},
					&cli.BoolFlag{
						Name:    "sort-due",
						Aliases: []string{"S"},
						Value:   false,
						Usage:   "sort list by due date",
					}},
					cmd_flags...,
				),
			},
		},
	}

	// ERROR
	if err := app.Run(os.Args); err != nil {
		log.Fatal(err)
	}
}

func newServiceClient(hostname string, port string, secure bool) todov1connect.TodoServiceClient {
	httpClient := &http.Client{
		Transport: &http2.Transport{
			AllowHTTP: !secure,
			DialTLS: func(network, addr string, _ *tls.Config) (net.Conn, error) {
				if !secure {
					return net.Dial(network, addr)
				} else {
					return tls.Dial(network, addr, &tls.Config{})
				}
			},
			IdleConnTimeout:  30 * time.Second,
			ReadIdleTimeout:  30 * time.Second,
			WriteByteTimeout: 30 * time.Second,
			PingTimeout:      30 * time.Second,
		},
	}

	protocol := "http"
	if secure {
		protocol = "https"
	}
	client := todov1connect.NewTodoServiceClient(
		httpClient,
		fmt.Sprintf("%s://%s:%s", protocol, hostname, port),
	)
	return client
}

func add(cCtx *cli.Context) {
	client := newServiceClient(cCtx.String("hostname"), cCtx.String("port"), cCtx.Bool("secure"))
	res, err := client.AddTodo(
		context.Background(),
		connect.NewRequest(&todov1.AddTodoRequest{
			Todo: &todov1.Todo{
				Title:       cCtx.String("title"),
				Description: cCtx.String("desc"),
				StatusId:    util.GetStatusID(cCtx.String("status")),
				DueDate:     cCtx.Timestamp("due-date").Unix(),
			},
		}),
	)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("Add new todo with ID: ", res.Msg.TodoId)
	log.Println("OK")
}

func addDummy(cCtx *cli.Context) {
	client := newServiceClient(cCtx.String("hostname"), cCtx.String("port"), cCtx.Bool("secure"))
	res, err := client.AddTodo(
		context.Background(),
		connect.NewRequest(&todov1.AddTodoRequest{
			Todo: &todov1.Todo{
				Title:       "Sample Todo",
				Description: "Sample Description",
				StatusId:    1,
				DueDate:     time.Date(time.Now().Year(), time.Now().Month(), time.Now().Day(), 0, 0, 0, 0, time.UTC).Unix(),
			},
		}),
	)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("Add new todo with ID: ", res.Msg.TodoId)
	log.Println("OK")
}

func get(cCtx *cli.Context) {
	client := newServiceClient(cCtx.String("hostname"), cCtx.String("port"), cCtx.Bool("secure"))
	res, err := client.GetTodo(
		context.Background(), connect.NewRequest(&todov1.GetTodoRequest{
			TodoId: cCtx.Args().Get(0),
		}),
	)
	if err != nil {
		log.Fatal(err)
	} else {
		log.Println("Get data: ", res.Msg)
	}
	log.Println("OK")
}

func edit(cCtx *cli.Context) {
	client := newServiceClient(cCtx.String("hostname"), cCtx.String("port"), cCtx.Bool("secure"))
	_, err := client.EditTodo(
		context.Background(),
		connect.NewRequest(&todov1.EditTodoRequest{
			Todo: &todov1.Todo{
				TodoId:      cCtx.String("id"),
				Title:       cCtx.String("title"),
				Description: cCtx.String("desc"),
				StatusId:    util.GetStatusID(cCtx.String("status")),
				DueDate:     cCtx.Timestamp("due-date").Unix(),
			},
		}),
	)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("OK")
}

func remove(cCtx *cli.Context) {
	client := newServiceClient(cCtx.String("hostname"), cCtx.String("port"), cCtx.Bool("secure"))
	_, err := client.RemoveTodo(
		context.Background(),
		connect.NewRequest(&todov1.RemoveTodoRequest{
			TodoId: cCtx.Args().Get(0),
		}),
	)
	if err != nil {
		log.Fatal(err)
	}
	log.Println("OK")
}

func list(cCtx *cli.Context) {
	client := newServiceClient(cCtx.String("hostname"), cCtx.String("port"), cCtx.Bool("secure"))
	stream, err := client.GetAllTodos(context.Background(), connect.NewRequest(&todov1.GetAllTodosRequest{
		FilterByStatusId: util.GetStatusID(cCtx.String("filter-by-status")),
		IsSortByDue:      cCtx.Bool("sort-due"),
	}))
	if err != nil {
		log.Fatal(err)
	}
	defer stream.Close()

	for stream.Receive() {
		msg := stream.Msg()
		log.Println(msg)
	}
	if err := stream.Err(); err != nil && !errors.Is(err, io.EOF) {
		log.Fatal(err)
	}
	log.Println("OK")
}
