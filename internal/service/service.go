package service

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"sort"
	"strconv"
	"sync"
	"time"

	todov1 "todo_module/internal/controller/gen/proto/v1" // generated by protoc-gen-go
	dbmodels "todo_module/internal/repository/db/models"  // generated by sqlboiler mysql

	_ "todo_module/internal/repository"

	"github.com/aarondl/null/v8"
	"github.com/aarondl/sqlboiler/v4/boil"
	_ "github.com/go-sql-driver/mysql"
)

type todoService struct{}

var once sync.Once
var instance *todoService

func GetInstance() *todoService {
	once.Do(func() {
		instance = &todoService{}
	})
	return instance
}

func (s todoService) CreateTodo(ctx context.Context, newTodo *todov1.Todo) (uint64, error) {
	tododb := &dbmodels.Todo{
		Title:       newTodo.Title,
		Description: null.StringFrom(newTodo.Description),
		StatusID:    newTodo.StatusId,
		DueDate:     null.TimeFrom(time.Unix(newTodo.DueDate, 0)),
	}
	err := tododb.InsertG(ctx, boil.Infer())
	if err != nil {
		return 0, err
	}
	id := tododb.TodoID
	slog.Info("CreateTodo new data id: ", id)
	return id, nil
}

func (s todoService) ReadTodo(ctx context.Context, id string) (*todov1.Todo, error) {
	idx, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return nil, err
	}
	tododb, err := dbmodels.FindTodoG(ctx, idx)
	if err != nil {
		return nil, err
	} else if tododb.DelFlag == true {
		return nil, errors.New("Todoが削除されました。")
	}
	slog.Info("ReadTodo data: ", tododb)
	todo := &todov1.Todo{
		Title:       tododb.Title,
		Description: tododb.Description.String,
		StatusId:    tododb.StatusID,
		DueDate:     tododb.DueDate.Time.Unix(),
	}
	return todo, nil
}

func (s todoService) UpdateTodo(ctx context.Context, newTodo *todov1.Todo) error {
	idx, err := strconv.ParseUint(newTodo.TodoId, 10, 64)
	if err != nil {
		return err
	}
	tododb, err := dbmodels.FindTodoG(ctx, idx)
	if err != nil {
		return err
	} else if tododb.DelFlag == true {
		return errors.New("削除されたTodoを更新することはできません。")
	}
	tododb = &dbmodels.Todo{
		TodoID:      idx,
		Title:       newTodo.Title,
		Description: null.StringFrom(newTodo.Description),
		StatusID:    newTodo.StatusId,
		DueDate:     null.TimeFrom(time.Unix(newTodo.DueDate, 0)),
	}
	rowsAff, err := tododb.UpdateG(ctx, boil.Infer()) //rowsAff:アップデート件数
	slog.Info("UpdateTodo rowAff: ", rowsAff)
	if err != nil {
		return err
	}
	return nil
}

func (s todoService) DeleteTodo(ctx context.Context, id string) error {
	idx, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return err
	}
	tododb, err := dbmodels.FindTodoG(ctx, idx)
	if err != nil {
		return err
	} else if tododb.DelFlag == true {
		return errors.New("もう既に削除されたTodoです。")
	}
	tododb.DelFlag = true                             // 論理削除フラグを立てる
	rowsAff, err := tododb.UpdateG(ctx, boil.Infer()) //rowsAff:アップデート件数
	slog.Info("DeleteTodo rowAff: ", rowsAff)
	if err != nil {
		return err
	}
	return nil
}

func (s todoService) ListTodo(ctx context.Context, filterByStatus uint64, isSortByDue bool) ([]*todov1.Todo, error) {
	var todos []*todov1.Todo
	list, err := dbmodels.Todos().AllG(ctx)
	if err != nil {
		return nil, err
	}
	for _, todo := range list {
		if todo.DelFlag == true {
			continue // 論理削除フラグが立っている場合はスキップ
		}

		// Filter by Status
		if filterByStatus != 0 && filterByStatus != todo.StatusID {
			continue
		}

		todos = append(todos, &todov1.Todo{
			TodoId:      fmt.Sprintf("%d", todo.TodoID),
			Title:       todo.Title,
			Description: todo.Description.String,
			StatusId:    todo.StatusID,
			DueDate:     todo.DueDate.Time.Unix(),
		})
	}

	// Sort by DueDate in ascending order
	if isSortByDue {
		sort.Slice(todos, func(i, j int) bool {
			return todos[i].DueDate < todos[j].DueDate
		})
	}

	return todos, nil
}
